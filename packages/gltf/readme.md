A small command-line tool that turns GLTF assets into declarative and re-usable [Threlte](https://threlte.xyz) components.

### The GLTF workflow on the web is not ideal ...

- GLTF is thrown wholesale into the scene which prevents re-use, in threejs objects can only be mounted once
- Contents can only be found by traversal which is cumbersome and slow
- Changes to queried nodes are made by mutation, which alters the source data and prevents re-use
- Re-structuring content, making nodes conditional or adding/removing is cumbersome
- Model compression is complex and not easily achieved
- Models often have unnecessary nodes that cause extra work and matrix updates

### @threlte/gltf fixes that

- üßë‚Äçüíª It creates a virtual graph of all objects and materials. Now you can easily alter contents and re-use.
- üèéÔ∏è The graph gets pruned (empty groups, unnecessary transforms, ...) and will perform better.
- ‚ö°Ô∏è It will optionally compress your model with up to 70%-90% size reduction.

## Usage

```bash
Usage
  $ npx @threlte/gltf [Model.glb] [options]

Options
  --output, -o        Output file name/path
  --types, -t         Add Typescript definitions
  --keepnames, -k     Keep original names
  --keepgroups, -K    Keep (empty) groups, disable pruning
  --meta, -m          Include metadata (as userData)
  --shadows, s        Let meshes cast and receive shadows
  --printwidth, w     Prettier printWidth (default: 120)
  --precision, -p     Number of fractional digits (default: 2)
  --draco, -d         Draco binary path
  --root, -r          Sets directory from which .gltf file is served
  --transform, -T     Transform the asset for the web (draco, prune, resize)
    --resolution, -R  Transform resolution for texture resizing (default: 1024)
    --simplify, -S    Transform simplification (default: false) (experimental!)
      --weld          Weld tolerance (default: 0.0001)
      --ratio         Simplifier ratio (default: 0.075)
      --error         Simplifier error threshold (default: 0.001)
  --debug, -D         Debug output
```

### A typical use-case

First you run your model through `@threlte/gltf`. `npx` allows you to use npm packages without installing them.

```bash
npx @threlte/gltf model.gltf --transform
```

This will create a `Model.svelte` file that plots out all of the assets contents.

```svelte
<!--
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@0.0.1 ./stacy.glb
-->
<script>
  import { Group } from 'three'
  import { T, Three } from '@threlte/core'
  import { useGltf, useGltfAnimations } from '@threlte/extras'

  export const ref = new Group()

  const { gltf } = useGltf('/stacy.glb')
  export const { actions, mixer } = useGltfAnimations(gltf, ref)
</script>

{#if $gltf}
  <Three type={ref} {...$$restProps}>
    <T.Group name="Scene">
      <T.Group name="Stacy" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <Three type={$gltf.nodes.mixamorigHips} />
        <T.SkinnedMesh
          name="stacy"
          geometry={$gltf.nodes.stacy.geometry}
          material={$gltf.nodes.stacy.material}
          skeleton={$gltf.nodes.stacy.skeleton}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
      </T.Group>
    </T.Group>

    <slot {ref} />
  </Three>
{/if}
```

Add your model to your `/public` folder as you would normally do. With the `--transform` flag it has created a compressed copy of it (in the above case `model-transformed.glb`). Without the flag just copy the original model.

```text
/public
  model-transformed.glb
```

The component can now be dropped into your scene.

```svelte
<script>
  import { Canvas } from '@threlte/core'
  import Model from './Model.svelte'
</script>

<Canvas>
  <Model />
</Canvas>
```

You can re-use it, it will re-use geometries and materials out of the box:

```svelte
<Model position={[0, 0, 0]} />
<Model position={[10, 0, -10]} />
```

Or make the model dynamic. Change its colors for example:

```svelte
<T.Mesh geometry={$gltf.nodes.robot.geometry} material={$gltf.materials.metal} material.color="green" />
```

Or exchange materials:

```svelte
<T.Mesh geometry={$gltf.nodes.robot.geometry}>
  <T.MeshPhysicalMaterial color="hotpink" />
</T.Mesh>
```

Make contents conditional:

```svelte
{#if condition}
  <T.Mesh geometry={$gltf.nodes.robot.geometry} material={$gltf.materials.metal} />}
{/if}
```

## Features

#### ‚ö°Ô∏è Draco and meshopt compression ootb

You don't need to do anything if your models are draco compressed, since `useGltf` defaults to a [draco CDN](https://www.gstatic.com/draco/v1/decoders/). By adding the `--draco` flag you can refer to [local binaries](https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco/gltf) which must reside in your /public folder.

#### ‚ö°Ô∏è Auto-transform (compression, resize)

With the `--transform` flag it creates a binary-packed, draco-compressed, texture-resized (1024x1024), webp compressed, deduped, instanced and pruned *.glb ready to be consumed on a web site. It uses [glTF-Transform](https://github.com/donmccurdy/glTF-Transform). This can reduce the size of an asset by 70%-90%.

It will not alter the original but create a copy and append `[modelname]-transformed.glb`.

#### ‚ö°Ô∏è Type-safety

Add the `--types` flag and your component will be typesafe.

```svelte
<!--
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@0.0.1 ./stacy.glb -t
-->
<script lang="ts">
  import type * as THREE from 'three'
  import { Group } from 'three'
  import { T, Three, type Props, type Events, type Slots } from '@threlte/core'
  import { useGltf, useGltfAnimations } from '@threlte/extras'

  type $$Props = Props<THREE.Group>
  type $$Events = Events<THREE.Group>
  type $$Slots = Slots<THREE.Group>

  export const ref = new Group()

  type ActionName = 'pockets' | 'rope' | 'swingdance' | 'jump' | 'react' | 'shrug' | 'wave' | 'golf' | 'idle'
  type GLTFResult = {
    nodes: {
      stacy: THREE.SkinnedMesh
      mixamorigHips: THREE.Bone
    }
    materials: {}
  }

  const { gltf } = useGltf<GLTFResult>('/stacy.glb')
  export const { actions, mixer } = useGltfAnimations<ActionName>(gltf, ref)
</script>

{#if $gltf}
  <Three type={ref} {...$$restProps}>
    <T.Group name="Scene">
      <T.Group name="Stacy" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
        <Three type={$gltf.nodes.mixamorigHips} />
        <T.SkinnedMesh
          name="stacy"
          geometry={$gltf.nodes.stacy.geometry}
          material={$gltf.nodes.stacy.material}
          skeleton={$gltf.nodes.stacy.skeleton}
          rotation={[-Math.PI / 2, 0, 0]}
          scale={100}
        />
      </T.Group>
    </T.Group>

    <slot {ref} />
  </Three>
{/if}
```

#### ‚ö°Ô∏è Easier access to animations

If your GLTF contains animations it will add [@threlte/extras's `useGltfAnimations`](https://threlte.xyz/extras/use-gltf-animations) hook, which extracts all clips and prepares them as actions:

```svelte
const { gltf } = useGltf('/stacy.glb')
export const { actions, mixer } = useGltfAnimations(gltf, ref)
```

If you want to play an animation you can do so at any time:

```ts
const onEvent = () => {
	$actions.jump.play()
}
```

## Using the parser stand-alone

```jsx
import { parse } from '@threlte/gltf'
import { GLTFLoader, DRACOLoader } from 'three-stdlib'

const gltfLoader = new GLTFLoader()
const dracoloader = new DRACOLoader()
dracoloader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/')
gltfLoader.setDRACOLoader(dracoloader)

gltfLoader.load(url, (gltf) => {
  const component = parse(filename, gltf, config)
})
```

## Requirements

- Nodejs must be installed
- The GLTF file has to be present in your projects `/public` folder
- [three](https://github.com/mrdoob/three.js/) (>= 122.x)
- @threlte/core > 5.0.0
- @threlte/core > 4.9.3

## Credits

This tool started off as a fork of [gltfjsx](https://github.com/pmndrs/gltfjsx) by [pmndrs](https://pmnd.rs/).
