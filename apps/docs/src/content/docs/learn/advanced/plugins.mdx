---
title: Plugins
sidebar: {
	order: 0
}
---

import Example from '$components/Example/Example.astro'

## Injecting a Plugin

### What it looks like

Plugins open up the component `<T>` to external code that will be injected via
context into every child instance of a `<T>` component. The callback function
receives a **reactive `args` object** that contains the `ref` of the respective
`<T>` component, all base props (`makeDefault`, `args`, `attach`, `manual`,
`makeDefault` and `dispose`) and all props (anything else) passed to it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('plugin-name', (args) => {
  console.log(args.ref) // e.g. a Mesh
  console.log(args.props) // e.g. { position: [0, 10, 0] }
})
```

If a plugin decides via `args.ref` or `args.props` analysis that it doesn't need
to act in the context of a certain `<T>` component, it can return early.

```ts
import { injectPlugin, isInstanceOf } from '@threlte/core'

injectPlugin('raycast-plugin', (args) => {
  if (!isInstanceOf(args.ref, 'Object3D') || !('raycast' in args.props)) return
})
```

The code of a plugin acts as if it would be part of the `<T>` component itself
and has access to all properties. A plugin can run arbitrary code in lifecycle
functions such as `onMount`, `onDestroy` and effects.

```ts
import { injectPlugin } from '@threlte/core'
import { onMount } from 'svelte'

injectPlugin('plugin-name', (args) => {
  // Use lifecycle hooks as if it would run inside a <T> component.
  // This code runs when the `<T>` component this plugin is injected
  // into is mounted.
  onMount(() => {
    console.log('onMount')
  })

  // Use any prop that is defined on the <T> component, in this
  // example `count`: <T.Mesh count={10} />
  const count = $derived(args.props.count ?? 0)

  $effect(() => {
    // This code runs whenever count changes.
    console.log(count)
  })

  return {
    // Claiming the property "count" so that the <T> component
    // does not act on it.
    pluginProps: ['count']
  }
})
```

A Plugin can also _claim properties_ so that the component `<T>` does not act on it.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('ecs', () => {
  return {
    // Without claiming the properties, <T> would apply the
    // property to the object.
    pluginProps: ['entity', 'health', 'velocity', 'position']
  }
})
```

Plugins are passed down by context and can be overridden to prevent the effects of a plugin for a certain tree.

```ts
import { injectPlugin } from '@threlte/core'

// this overrides the plugin with the name "plugin-name" for all child components.
injectPlugin('plugin-name', () => {})
```

### Creating a Plugin

Plugins can also be _created_ for external consumption. This creates a _named plugin_. The name is used to identify the plugin and to override it.

```ts
import { createPlugin } from '@threlte/core'

export const layersPlugin = createPlugin('layers', () => {
  // ... Plugin Code
})
```

```ts
// somewhere else, e.g. in a component

import { injectPlugin } from '@threlte/core'
import { layersPlugin } from '$plugins'

injectPlugin(layersPlugin)
```

## Examples

### `lookAt`

This is en example implementation that adds the property `lookAt` to all `<T>` components, so that `<T.Mesh lookAt={[0, 10, 0]} />` is possible:

<Example path="plugins/lookAt" />

### BVH Raycast Plugin

A Plugin that implements [BVH raycasting](https://github.com/gkjohnson/three-mesh-bvh) on all child meshes and geometries.

```ts title="bvhRaycasting.svelte.ts"
import { injectPlugin, isInstanceOf } from '@threlte/core'
import type { BufferGeometry, Mesh } from 'three'
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from 'three-mesh-bvh'

const bvhRaycasting = () => {
  injectPlugin('bvh-raycast', (args) => {
    $effect(() => {
      if (isInstanceOf(args.ref, 'BufferGeometry')) {
        args.ref.computeBoundsTree = computeBoundsTree
        args.ref.disposeBoundsTree = disposeBoundsTree
        args.ref.computeBoundsTree()
      }
      if (isInstanceOf(args.ref, 'Mesh')) {
        args.ref.raycast = acceleratedRaycast
      }
      return () => {
        if (isInstanceOf(args.ref, 'BufferGeometry')) {
          args.ref.disposeBoundsTree()
        }
      }
    })
  })
}
```

Implementing this plugin in your Scene:

```svelte title="Scene.svelte"
<script lang="ts">
  import { T } from '@threlte/core'
  import bvhRaycasting from './plugins/bvhRaycasting.svelte'

  bvhRaycasting()
</script>

<T.Mesh>
  <T.MeshBasicMaterial />
  <T.BoxGeometry />
</T.Mesh>
```
