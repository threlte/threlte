This example demonstrates a well-known technique for doing simple postprocessing utilizing a "screen-quad".

<Example path="postprocessing/screen-quad" />

## Overview

The basic idea of postprocessing is to draw the scene to a frame-buffer ortexture that can then be sent into another shader. The output of this shader is used as the texture or material for a mesh that covers the screen. To do this we need two things:

1. a WebGL render target.
2. a separate scene from the one that Threlte provides.

Threlte's `useFBO` can give us a [WebGLRenderTarget](https://threejs.org/docs/index.html?q=webgl#api/en/renderers/WebGLRenderTarget) that automatically resizes when the size of the canvas updates.

A separate scene is needed so that we can add the screen-quad mesh to it and render it. The only object in the this scene will be the screen-quad mesh with the post-processed shader applied.

The steps are as follows:

1. Render the "main" scene to the render target. The target's texture is passed as a uniform into the post-procssing shader.
2. Render the scene that only contains the screen-quad mesh. This is what will be displayed on the canvas.

There are some sub-steps inbetween but these are the two important bits that happen in the `useTask` callback in the `<Scene>` component.

## ScreenQuadGeometry

This component creates a buffer geometry triangle such that its right angle is positioned in the lower left of the canvas. The size of the triangle is such that the hypotenuse only touches the top right corner of the canvas. The triangle is in clip-space so we need a special vertex shader to use it.

The vertex shader string is exported from the `<ScreenQuadGeometry>` component to be used with either a `Three.RawShaderMaterial` or `Three.ShaderMaterial`.

## Scene

There are a few notable techniques in the `<Scene>` component.

Firstly, The screen-quad mesh is not frustrum culled. This is because the geometry is always visible, so no point in culling it.

This `<T.Mesh>` uses threlte's `attach` prop to add it to the secondary scene instead of the default scene created by threlte.

Secondly, the render task that threlte automatically uses is disabled and a custom render task is used instead. This is explained on the [`useTask`](/docs/reference/core/use-task) page.

Lastly, the uvs are used in the fragment shader as an index into the render target's texture. Note that you can get a perfect circle by sending the size of the renderer into the fragment shader as a uniform.

```ts
const fragmentShader = `
	// ...
	uniform vec2 uSize;

	vec2 uv = gl_FragCoord.xy / uSize.xy;
	// ...
`

const uSize = new Uniform(new Vector2())

const { size } = useThrelte()

$effect(() => {
  uSize.value.set($size.width, $size.height)
})

const material = new RawShaderMaterial({
  fragmentShader,
  vertexShader,
  uniforms: {
    uSize
  }
})
```
