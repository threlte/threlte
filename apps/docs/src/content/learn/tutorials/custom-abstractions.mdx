---
category: Tutorials
title: Custom Abstractions
order: 10
---

## Components

A lot of the components you will find in the package [@threlte/extras](/docs/reference/extras/getting-started)
are abstractions on top of the [`<T>` component](/docs/reference/core/t). These abstractions provide extra functionality like automatically
invalidating the frame or providing default values or extra props.

A common use case for custom abstractions is to create a component that is a fixed entity in your Threlte app which you want to reuse
in multiple places. As an example, let's create a component that is made up from multiple `<T>` components resembling a floor and a cube on top:

{/* prettier-ignore-start */}
```svelte title="Tile.svelte"
<script>
  import { T } from '@threlte/threlte'
  import { DEG2RAD } from 'three/src/math/MathUtils'
</script>

<T.Group>
  <!-- 1x1x1 Cube -->
  <T.Mesh
    position.y={0.5}
  >
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- 2x2 Floor -->
  <T.Mesh
    rotation.x={-90 * DEG2RAD}
  >
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- A slot to nest objects in -->
  <slot />
</T.Group>
```
{/* prettier-ignore-end */}

Let's see what implementing that component looks like:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile />
```

### Props

The `<Tile>` component is now available in the scene and can be reused as many times as you want.
Now we'd like to assign a different `position` to the `<Tile>` component in order to move it around.
We can do that by passing a `position` prop to the `<Tile>` component:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile position={[0, 0, 0]} />
<Tile position={[2, 0, 0]} />
<Tile position={[4, 0, 0]} />
```

The component `<Tile>` internally needs to use the `position` prop in order to set the position of the `<T>` components. We can do that by
[spreading `$$restProps` on the `<T.Group>`](https://svelte.dev/tutorial/spread-props) component at the root hierarchy of `<Tile>`:

{/* prettier-ignore-start */}
```svelte title="Tile.svelte" {6}m
<script>
  import { T } from '@threlte/threlte'
  import { DEG2RAD } from 'three/src/math/MathUtils'
</script>

<T.Group {...$$restProps}>
  <!-- 1x1x1 Cube -->
  <T.Mesh
    position.y={0.5}
  >
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- A slot to nest objects in -->
  <slot />
</T.Group>
```
{/* prettier-ignore-end */}

### Events

<Tip type="info">
  The following section assumes you use the plugin
  [interactivity](/docs/reference/extras/interactivity) to listen to pointer events.
</Tip>

We successfully forwarded all props and are able to move the `<Tile>` component around in the scene.
However, we may also need to listen to events on objects inside `<Tile>`. Threlte provides the
[utility function `forwardEventHandlers`](/docs/reference/core/utilities#forwardeventhandlers)
to forward event handlers defined on `<Tile>` internally to our cubes `<T.Mesh>` component.

{/* prettier-ignore-start */}
```svelte title="Tile.svelte" {2}m {5,12}+
<script>
  import { T, forwardEventHandlers } from '@threlte/threlte'
  import { DEG2RAD } from 'three/src/math/MathUtils'

  const component = forwardEventHandlers()
</script>

<T.Group {...$$restProps}>
  <!-- 1x1x1 Cube -->
  <T.Mesh
    position.y={0.5}
    bind:this={$component}
  >
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- A slot to nest objects in -->
  <slot />
</T.Group>
```
{/* prettier-ignore-end */}

When we now add an `on:click` event handler to the `<Tile>` component, we can see that the event handler is called when we click on the floor:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<Tile
  on:click={() => {
    console.log('clicked')
  }}
/>
```

### Types

<Tip type="info">The following section assumes you use TypeScript.</Tip>

The last thing we need to do is to add types to our custom abstraction so that editors like VSCode can provide us with autocompletion and type checking.
We will create a `Tile.d.ts` file next to the `Tile.svelte` file and add the following content:

```ts title="Tile.d.ts"
import type { Events, Props, Slots } from '@threlte/core'
import { SvelteComponentTyped } from 'svelte'
import type { Group } from 'three'

export type TileProps = Props<Group> & {
  // Define extra props here.
}

export type TileEvents = Events<Mesh> & {
  // Define extra events here.
}

export type TileSlots = Slots<Mesh> & {
  // Define extra slots here.
}

export default class Tile extends SvelteComponentTyped<TileProps, TileEvents, TileSlots> {}
```

Now we can use the `<Tile>` component in our scene and get autocompletion and type checking:

```svelte title="Scene.svelte"
<script>
  import Tile from './Tile.svelte'
</script>

<!-- Autocompletion and type checking works here. -->
<Tile position={[0, 0, 0]} />
```

Let's cross check the types inside our `Tile.svelte` file by implementing `$$Props`, `$$Events` and `$$Slots`. We immediately see that we forgot to
pass the slot prop `ref` to our `<slot />`, let's add that:

{/* prettier-ignore-start */}
```svelte title="Tile.svelte" {1,13,30}m {4,6-8}+
<script lang="ts">
  import { T, forwardEventHandlers } from '@threlte/threlte'
  import { DEG2RAD } from 'three/src/math/MathUtils'
  import type { TileProps, TileEvents, TileSlots } from './Tile.svelte'

  type $$Props = TileProps
  type $$Events = TileEvents
  type $$Slots = TileSlots

  const component = forwardEventHandlers()
</script>

<T.Group {...$$restProps} let:ref>
  <!-- 1x1x1 Cube -->
  <T.Mesh
    position.y={0.5}
    bind:this={$component}
  >
    <T.BoxGeometry />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- 2x2 Floor -->
  <T.Mesh rotation.x={-90 * DEG2RAD}>
    <T.PlaneGeometry args={[2, 2]} />
    <T.MeshStandardMaterial />
  </T.Mesh>

  <!-- A slot to nest objects in -->
  <slot {ref} />
</T.Group>
```
{/* prettier-ignore-end */}

## Plugins

Plugins are one of Threlte's superpowers. Plugins allow you to globally extend Threlte's [`<T>`](/docs/reference/core/t) component
functionality. This means you can not only add arbitrary props and event handlers to your `<T>` components but also
override the default behavior of the `<T>` component entirely.

Plugins add code to every `<T>` component instance. That code acts as if it were part of the `<T>` component itself.
You have full access to props, event listeners and the component instance itself. For an advanced example of what
a plugin can do, see the [interactivity plugin of `@threlte/extras`](/docs/reference/extras/interactivity).

### `injectPlugin`

The function `injectPlugin` adds a plugin to all descendant `<T>` components of the component that
invokes it. This means that you can add plugins to a specific part of your scene graph without
affecting the rest of the scene graph.

```ts
import { injectPlugin } from '@threlte/core'

injectPlugin('plugin-name', ({ ref, props }) => {
  // We are *inside* a `<T>` component instance

  // Do something with the ref and props
  // e.g. return early if the plugin is not applicable

  return {
    // These props are reserved for this plugin, the
    // `<T>` component instance will not act on them.
    pluginProps: ['plugin-prop-a', 'plugin-prop-b'],

    // this function is called whenever the `ref` inside the `<T>`
    // component changes. You may return a cleanup function that is
    // called when the ref changes again or the component unmounts.
    onRefChange: (ref) => {
      // Do something with the ref
      return () => {
        // Cleanup
      }
    },

    // This function is called whenever the $$props of the `<T>` component
    // change. These include props like "dispose", "args" and "makeDefault"
    // that are part of the component itself rather than the props that are
    // passed to the Three.js object.
    onPropsChange: (props) => {
      // Do something with the props
    },

    // This function is called whenever the $$restProps of the `<T>` component
    // change. These are the props that are passed to the Three.js object.
    onRestPropsChange: (restProps) => {
      // Do something with the restProps
    }
  }
})
```

You may also override a plugin namespace further down the tree by calling `injectPlugin` again with the same plugin name.

<Tip type="tip">
	`injectPlugin` is relying on a context provided by your root `<Canvas>` component and can therefore only be used inside a `<Canvas>` component.
</Tip>

---

### `createPlugin`

The function `createPlugin` creates a `NamedPlugin` but does not add it to the global plugin list and therefore does not
make it available to all `<T>` components. This is useful if you want to create a plugin at some place and inject it at another.

```ts title="plugin.ts"
import { createPlugin } from '@threlte/core'

export const plugin = createPlugin('plugin-name', ({ ref, props }) => {
  // Plugin Code
})
```

```svelte title="Component.svelte"
<script lang="ts">
  import { injectPlugin } from '@threlte/core'
  import { plugin } from './plugin'

  injectPlugin(plugin)
</script>
```
